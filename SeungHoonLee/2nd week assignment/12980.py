"""
LV2. 점프와 순간 이동
[https://school.programmers.co.kr/learn/courses/30/lessons/12980]

---

[첫번째 시도: 다이나믹 프로그래밍]
- dist에 대해 기존에 구한 값을 활용하면 최솟값을 구할 수 있으리라 추측.
- dist를 이동할 때 (기존 거리 * 2) 또는 K만큼 이동이므로,
- dist = dist//2 + dist%2를 사용하면 거리의 최솟값을 구할 수 있으리라 추측.

    - [dp[i]: 거리 i를 이동할 때 필요한 건전지 사용량의 최솟값]이라 하면:
    - dist가 2의 승수인 경우 결과는 무조건 1이므로, dist[2^i] = 1
    - 따라서 점화식은 다음과 같다.
        - dp[i] = dp[i//2] + dp[i%2]
        - dp[0] = 0, dp[1] = 1

    - e.g. N = 3
        - dp[3] = dp[1] + dp[1] = 1 + 1 = 2
    - e.g. N = 7
        - dp[7] = dp[3] + dp[1] = 2 + 1 = 3

- 풀이 실패
    - 효율성 통과 안됨
    - 이유: 문제에서는 적어도 O(N)보다 더 빠른 알고리즘으로 풀어야 되는 것으로 추측
---

[solution 1: 거리가 0이 될 때까지 2로 나눈 몫 중 홀수의 개수 세기]

- 거리 1부터 dist까지 순서대로 이동한 결과 값에서 점프한 횟수가 건전지 사용량의 최솟값이 된다.

    - e.g. dist = 4
        - 점프(1) -> 순간이동(2) -> 순간이동(4)
        - 점프 횟수는 1(1)

    - e.g. dist = 5
        - 점프(1) -> 순간이동(2) -> 순간이동(4) -> 점프(5)
        - 점프 횟수는 2(1 -> 5) // 1 -> 2 -> 5

    - e.g. dist = 6
        - 점프(1) -> 순간이동(2) -> 점프(3) -> 순간이동(6)
        - 점프 횟수는 2번(1 -> 3)

    - e.g. dist = 7
        - 점프(1) -> 순간이동(2) -> 점프(3) -> 순간이동(6) -> 점프(7)
        - 점프 횟수는 3번(1 -> 3 -> 7)

    - e.g. dist = 8
        - 점프(1) -> 순간이동(2) -> 순간이동(4) -> 순간이동(8)
        - 점프 횟수는 1번(1)

    - e.g. dist = 9
        - 점프(1) -> 순간이동(2) -> 순간이동(4) -> 순간이동(8) -> 점프(9)
        - 점프 횟수는 2번(1 -> 9) // 1 -> 2 -> 4 -> 9

- 위 계산 결과 점프 횟수는 dist를 2로 나누었을 때, 몫 중 홀수의 개수와 동일하다.
- 각 숫자를 0이 될 때까지 2로 나누었을 때 몫 값만 표기하면 다음과 같다.

| dist | quotients                                                           | f(dist) |
| ---- | ------------------------------------------------------------------- | ------- |
| 1    | 1 - 0                                                               | 1       |
| 2    | 2 - 1 - 0                                                           | 1       |
| 3    | 3 - 1 - 0                                                           | 2       |
| 4    | 4 - 2 - 1 - 0                                                       | 1       |
| 5    | 5 - 2 - 1 - 0                                                       | 2       |
| 6    | 6 - 3 - 1 - 0                                                       | 2       |
| 7    | 7 - 3 - 1 - 0                                                       | 3       |
| 8    | 8 - 4 - 2 - 1 - 0                                                   | 1       |
| 9    | 9 - 4 - 2 - 1 - 0                                                   | 2       |
| 10   | 10 - 5 - 2 - 1 - 0                                                  | 2       |
| 12   | 12 - 6 - 3 - 2 - 1 - 0                                              | 2       |
| 16   | 16 - 8 - 4 - 2 - 1 - 0                                              | 1       |
| 5000 | 5000 - 2500 - 1250 - 625 - 312 - 106 - 53 - 26 - 13 - 6 - 3 - 1 - 0 | 5       |

- 위 결과를 보면 몫의 값 중 홀수의 개수가 f(dist)와 일치하는 것을 확인할 수 있다.

---

[solution 2: 2진수로 변환했을 때의 1의 개수 세기]

1부터 10까지 dist에 대한 f(dist)는 다음과 같다.

| dist | f(dist) |
| ---- | ------- |
| 1    | 1       |
| 2    | 1       |
| 3    | 2       |
| 4    | 1       |
| 5    | 2       |
| 6    | 2       |
| 7    | 3       |
| 8    | 1       |
| 9    | 2       |
| 10   | 2       |
| 5000 | 5       |

이때 dist를 이진수로 변환하면 다음과 같다.

| dist | f(dist) | bin(dist)        |
| ---- | ------- | ---------------- |
| 1    | 1       | 0000             |
| 2    | 1       | 0001             |
| 3    | 2       | 0011             |
| 4    | 1       | 0100             |
| 5    | 2       | 0101             |
| 6    | 2       | 0110             |
| 7    | 3       | 0111             |
| 8    | 1       | 1000             |
| 9    | 2       | 1001             |
| 10   | 2       | 1010             |
| 5000 | 5       | 1 0011 1000 1000 |

위 표를 보면 각 dist의 2진수에서 1의 개수와 f(dist)의 값이 동일함을 알 수 있다.
따라서 단순히 2진수로 변환했을 때 1의 개수만 세면 결과를 구할 수 있다.
"""


def solution(n):
    """
    첫 번째 시도: 다이나믹 프로그래밍 (실패)
    """
    if n <= 1:
        return n

    dp = [0] * (n//2 + 1)
    dp[1] = 1

    for i in range(2, n//2 + 1):
        dp[i] = dp[i // 2] + dp[i % 2]

    return dp[n//2] + dp[n%2]


def solution1(n):
    """
    거리가 0이 될 때까지 2로 나눈 몫 중 홀수의 개수 세기
    """
    return len([curr for i in range(n.bit_length()) if (curr := n >> i) % 2 != 0])


def solution2(n):
    """
    첫 번째 시도: 2진수로 변환했을 때의 1의 개수 세기
    """
    return bin(n).count('1')
