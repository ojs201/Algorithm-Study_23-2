"""
LV2. 줄 서는 방법
[https://school.programmers.co.kr/learn/courses/30/lessons/12936]

인덱스 변환 공식 필요 (1차원 - 2차원)
: arr1D[i] = arr2D[i/column][i%column]
: arr2D에서 k번째 요소 => arr1D[k-1] = arr2D[(k-1)/column][(k-1)%column]

e.g. arr1D[4] = arr2D[4/3][4%3] = arr2D[1][1]

- 주어진 문제에서 n명의 사람들이 줄을 서는 경우는 n!
- 이때 주어진 경우의 수 중 앞 자리 수가 바뀌는 주기는 (n-1)! 이다.
    - e.g. n = 3 일때, 경우의 수: 3! = 6, 앞자리 수는 2(=(3-1)!)번째 이후로 바뀐다.
- 이때 주어진 경우의 수를 앞 자리 수를 기준으로 정렬하면 다음과 같은 2차원 배열로 표현할 수 있음

arr2D[n][(n-1)!] = [
    [[1, 2, 3], [1, 3, 2]],
    [[2, 1, 3], [2, 3, 1]],
    [[3, 1, 2], [3, 2, 1]]
]

따라서 k번째 수를 구할 때, arr1D[k] = arr2D[(k-1)/column][(k-1)%column] 공식 이용 가능
이때 column은 (n-1)!이므로, arr1D[k] = arr2D[(k-1)/(n-1)!][(k-1)%(n-1)!]

    n = 3, k = 5, arr1D[4] = arr2d[4/2][4%2] = arr2d[2][0]

단, 문제에서 arr2D를 만들면 시간 초과
- 따라서 약간의 트릭이 필요, 문제를 잘 살펴보면 경우의 수에 재귀적으로 반복되는 패턴이 있음을 확인할 수 있다.

e,g, n = 4 일때 앞 자리가 1인 수만 보면

1 2 3 4
1 2 4 3
1 3 2 4
1 3 4 2
1 4 2 3
1 4 3 2
...

- 1번째 자리 -> 6개 이후 바뀜 (3!)
- 2번째 자리 -> 2개 이후 바뀜 (2!)
- 3번째 자리 -> 1개 이후 바뀜 (1!)
- 마지막 -> 쩌리(?)

- 즉, 경우의 수의 구조가 '(n-1)!의 크기를 가지는 배열이 중첩하여 반복되는 구조'로 볼 수 있다.
- 따라서 중접되는 배열에서 (k-1)/(n-1)!에 해당하는 값을 모으면 답을 구할 수 있다.

- e.g. (n = 4)
    - 1번째 배열의 인덱스 -> (k-1) / (n-1)!
    - 2번째 배열의 인덱스 -> (k % (n-1)! - 1) / (n-2)!
    - 3번째 배열의 인덱스 -> (k % (n-2)! - 1) / (n-3)!
    - 마지막 -> 쩌리

e.g. (n = 4, k = 5) nums = [1,2,3,4]
    - 1번째 자리 -> (5-1) / 3! => 4 / 6 => 0 [1] -> [2,3,4]
    - 2번째 자리 -> (5 % 3! - 1) / 2! => 4 / 2 => 2 [4] -> [2,3]
    - 3번째 자리 -> (5 % 2! - 1) / 1! => 0 / 1 => 0 -> [2]
    - 마지막 -> 쩌리 -> [3]

=> [1, 4, 2, 3]
"""
from math import factorial


def solution(n, k):
    people = list(range(1, n + 1))
    factorials = [factorial(i) for i in range(n - 1, 0, -1)]
    answer = []

    for factorial_num in factorials:
        q = (k - 1) // factorial_num
        answer.append(people.pop(q))
        k %= factorial_num

    return answer + people


print(solution(4, 5))
